把同步放到Gateway,由Gateway来广播，Gateway保存每个客户端的角色所在的地址，并放到对应的地图列表中。
Gateway每收到一条同步消息，立即查找其地图，并查找其周围的客户端，然后广播。
好处是广播和GS无关，GS和地图无关，需要设计一个地图服务器，广播周围角色的进出情况。
同时有这个地图服务器计算每个人需要广播的Gateway的列表.
即同时在GW和MapServer上保持两个地图列表.广播单位为2屏，按4格计算。这样每步走动只会引起4个消息。
在MapServer按一屏为一个session进行计算.
每个服务器都记录一张地图每一个屏对应的session所在地的列表。
如果挂了，则失去所管区域的地图进出控制
//尽量把同一地图Session放在一台服务器上.
MapMagagerServer
地图管理器，保存所有地图session的地址和在线人数，同时根据人数进行MapSession迁移控制.
如果挂了，则失去MapSession迁移控制
//MapSession的迁移算法
//现在远端创建一个MapSession,创建成功后，把本地图的所有信息一起发过去Init,然后转发之后收到的
//的每一条请求.同时，对每一个CharServer（CharServer上保持一个所有地图session的Map表,要10M内存？相当于MapMangerServer数据的一个镜像）发送session迁移通知
//在所有CharServer确认后(即以后不会再从该CharServer收到消息)，释放这个session.
//迁移完成

地图服务器只管理人物的进出、移动控制，范围技能直接转发给相关联的GS，由GS进行具体的距离判定.


每个GW只能接入2000人，性能应该可以，最差情况下，就是每个都广播，那就是2000*n条.
100 * 50 = 5K * 2k = 100M
按距离进行广播，先播近的，远的就扔掉不播放。
最差情况下，会收到10K*4 = 40K/s服务器性能是
NPC向GW注册关心的角色，以一个NPCService为注册单位。NPC控制NPCCharactor.NPCService可以不必关系NPCCharactor在哪儿。
每一个NPCService控制一个地图上的所有NPCCharactor。

同步角色基本数据。

关于NPC，按一个服务器来注册，
限制每个地图1万人，这样的话，每个npc只要记录200人/组队对他的伤害
每个人记录对他有仇恨的NPC列表,然后成对的增删。每个人最多有100个仇视他的NPC.
struct THitRecord
{
	TUInt32 m_nType:4; //阵营/种族/帮派/战队/组队/兄弟/夫妻/个人
	TUInt32 m_nId:28; //服务器内部ID.
	TUInt32 m_nRecord;
	TUInt32 m_nLastAttackTime; 12
};
TplNode<THitRecord*> 20



28

10K * 4K = 40M;

普通怪16个； 6000个 48000  //150K * 46 = 6900k = 6.9m
精英 32个； 1000个 16000
领袖 64个； 200个  6400
Boss 128个； 50个   3200
地图Boss 256个 4个 512
世界级Boss 512个 1 256
唯一Boss 1024个

50k怪
//20K个实际量
5k 

class CCharater
{
	void OnHpChanged(int hp);
	void OnMpChanged(int hp);
};

容器为对象确定东西.通过接口
对象通知容器事件,可以注册64个事件，按bit保存

地图，分级，最高级为一个同步范围。
65536 * 65536 格
4个格子
人数\ 2 * 2 指针
class CGrid
{
	TUInt16 m_sCharNr;
	TUInt16 m_sHierachy;
	void*   m_pLowGrid[2][2];
};
32 16 8 4 2 
5个 40K 200K * 20 = 4M

设计思路：
不要有下级回调上级功能的设定，只能有平级之间的调用，
如果一个功能有多个下级模块涉及到，则这个功能应该写在统一管辖着多个下级模块的上级模块内.
如：CConectionMgr，提供ConnectionPool\Listener\Connector\EventQueue四个模块，这三个模块不需要CConectionMgr,Listener只要ConnectionPool就够了


再比如设计人物角色时：
ItemMgr只要管理物品增删，数据库存储就够了
物品的作用，由于可能涉及到整个人物的各个属性，可以作为CChar的成员，或者写一个单独的模块来处理。
这个模块的入参事Item \ CChar

Char　也分为多个子模块，如Itembag\equipment\Attr\pos\fightingAttr,

一个对外暴露的接口，内部就不该再使用？
不然的话，外部很难知道内部是否已经调用过这个借口.


任务挂接在人物身上，限定任务完成方式：对话，杀挂,(杀人?)，收集物品，到达某地（客户端检测）；人物要分为多个状态，在不同状态下使用相同物品有不同效果.
集体任务：杀怪争夺赛，资源争夺赛。在线副本进行，离线放弃。
唯一任务：每个时间段只有一个人能做，下线即放弃。
随机任务：随机给，下线即放弃，也是非唯一。
实物任务：把一个实物拆成多份，然后集齐组装后可以兑换实物,贵重的不可交易，或者交易需要钱。
选秀：投票系统。
城镇系统：和特定NPC有有好度。主动弹对话框。
人肉NPC：
发布任务（赏金猎人）:可以用自己的经验、金钱、物品来发布；
工会老大每月可以自己发布一定任务给自己工会的人;但是有限制,会要求工会等级、工会贡献度等。
奇遇任务：地点触发，服务器给,随机刷NPC。

事件注册：通过Action来做

人物可以有很多事件，每个事件可以触发一些行动（Action）
事件如：准备使用物品（可以限制使用物品），使用物品（可以做各种效果(脚本)）,
假设我们要设计一张地图：能使用红，并且如果身上有一个特殊buffX，则每次使用为加其身上的蓝的数量，然后继续安正常加红，并且这张地图不能用蓝
则需要设计这样一个Action:（准备使用物品），如果物品为蓝瓶，则返回-1；
		  另一个Action(使用物品Action),判断是否有buffX,有责加蓝，返回0，
	          返回-1，则中断流程，返回0，则继续，返回n，则跳过后面一步，表示动作被替。


人物事件有：开始战斗->战斗
            开始使用物品->使用物品
            开始组队->组队
            开始推出队伍->退出队伍
            开始死亡(限制死亡)->死亡（修改死亡惩罚）
            被攻击
            (一秒流逝)
假设有5个buff,*3000.

光环：客户端判断，增益光环,由受众申请，减益光环，主动方申请。光环逃脱由地图服务器判断或者客户端主动申请。

方案2：主动标示，光环释放者在地图格子上打个标记（每个玩家按最大光环10*10=100个，12个字节=1.2k. * 10K = 12M）。玩家进入时加，退出时减。服务器很累.每步100个.
光环拥有者每走一步，要为新进入玩家加上。
个人光环(只要是玩家就能被加上)、组队光环、阵营光环、帮派光环.一旦选定攻击模式，只能享受和其攻击模式相同的光环.光环和人物属性无关，只和光环等级有关.

方案4：地图服务器外，再加一个范围技能、光环控制服务器。

可以一个ServerContainer里开4个地图服务+地图服务管理（4cpu，20kplayer+40kNpc）（1个服务）
外加一个范围技能+光环控制服务，开4个+管理（4cpu）（4cpu，20kplayer+40kNpc）
数据库 4台（8CPU）。(SS+MM+IDB+CDB+LS)

GS10个服务+10个NPC+10GW 10台（4cpu）

LS+PCS


未来的方向：服务器进行存储、数值计算、地图控制，将广播放到客户端.即B2B。

分：路径服务器（校验行走有效性（1）），群攻+光环服务器，放中心.

地图服务器（通知玩家其它单元的进出），
可以把除GW外的所有服务器放在一个机房，GW放在不同机房做接入，然后走一个100M进入主机房.
在每个接入点接入20k人，并且安排一个分区地图服务，地图服务。

在大逻辑上：所有数值计算都在中心机房，接入在各个分机房，各个分机房自行处理地图人物的进出（通信量比较大）。加上每个分机房只有2w接入，发送信息为1M（20K*2*25字节/秒），接收为50M
(1M*50区)。
先地区，后大区域，最后国。